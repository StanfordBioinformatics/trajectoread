#!usr/bin/env python
"""
Description: Convert bcl files output by illumina sequencing platforms to unmapped 
             fastq files. It will be the first applet called by most sequence 
             processing workflows on DNAnexus.
Args : DNAnexus ID of dashboard record for sequencing lane project
Returns : 
Author : pbilling
"""

__author__ = 'pbilling@stanford.edu (Paul Billing-Ross)'


import os
import re
import sys
import dxpy
import time
import json
import shutil
import fnmatch
import datetime
import subprocess

def download_file(file_dxid):
    """
    Args    : dx_file - a file object ID on DNAnexus to the current working directory.
    Returns : str. Path to downloaded file.
    """
    dx_file = dxpy.DXFile(file_dxid)
    filename = dx_file.describe()['name']
    dxpy.download_dxfile(dxid=dx_file.get_id(), filename=filename)
    return filename


def upload_files(pattern, location, record_link):
    ''' DEV: Look into using glob.glob to find all fastq files instead of 
             manually listing the directories and searching them, a la 
             implementation in gbsc/gbsc_utils/demultiplexing.py.
        DEV: Upload
    '''
    
    fastq_files = []
    fastqs_subfolder = output_folder + '/fastqs'
    misc_subfolder = output_folder + '/miscellany'
    lane_dir = self.home + '/Unaligned_L' + str(self.lane_index)

    # Upload lane.html file
    self.lane_barcode = self.get_lane_barcode()
    report_html_file = 'Unaligned_L%d/Reports/html/%s/all/all/all/lane.html' % (self.lane_index, self.lane_barcode)
    properties = {
                  'run_date':   str(self.run_date),
                  'run_name':   str(self.run_name),
                  'library_id': str(self.library_id),
                  'lane_id':    str(self.lane_id),
                  'lane_index': str(self.lane_index),
                  'library_name': str(self.library_name)
                 }
    '''
    lane_html_name = 'SCGPM_%s_%s_%s_L%d.lane.html' % (self.run_date,
                                                       self.library_name, 
                                                       self.flowcell_id,
                                                       self.lane_index 
                                                      )
    '''
    lane_html_name = '%s_L%d.lane.html' % (self.run_name, int(self.lane_index))
    lane_html_file = dxpy.upload_local_file(filename = report_html_file,
                                            name =  lane_html_name,
                                            properties = properties, 
                                            project = self.lane_project_id, 
                                            folder = misc_subfolder, 
                                            parents = True
                                           )
    # Dev: Instead of doing complicated searching, recursively find all *.fastq.gz files
    # Upload fastq files generated by bcl2fastq version 2 (2.17.-)
    elif self.bcl2fastq_version == 2:
        flowcell_dir = lane_dir + '/' + self.flowcell_id
        
        # Upload all the fastq files from the lane directory (Unaligned_L%d)            
        os.chdir(lane_dir)
        for filename in os.listdir('.'):
            if fnmatch.fnmatch(filename, '*.fastq.gz'):
                print filename

                scgpm_names = self.get_SCGPM_fastq_name_rta_v2(filename)
                scgpm_fastq_name = scgpm_names[0]
                barcode = scgpm_names[1]
                try:
                    barcode_name = self.barcode_dict[barcode]
                    barcode_name = re.sub(r"[^a-zA-Z0-9]+", "-", barcode_name)
                except:
                    barcode_name = None
                read_index = scgpm_names[2]
                if barcode_name:
                    fastq_name_v2 = 'SCGPM_%s_%s_L%d_%s_%s_R%d.fastq.gz' % (self.library_name, 
                                                                            self.flowcell_id,
                                                                            self.lane_index,  
                                                                            barcode,
                                                                            barcode_name, 
                                                                            int(read_index))
                else:
                    fastq_name_v2 = 'SCGPM_%s_%s_L%d_%s_R%d.fastq.gz' % (self.library_name, 
                                                                         self.flowcell_id,
                                                                         self.lane_index,  
                                                                         barcode,
                                                                         int(read_index))
                properties = {
                              'run_date': str(self.run_date),
                              'run_name': str(self.run_name),
                              'library_id': str(self.library_id),
                              'barcode': str(barcode),
                              'read': str(read_index),
                              'lane_index': str(self.lane_index),
                              'lane_id': str(self.lane_id),
                              'library_name': str(self.library_name)
                             }
                if barcode_name:
                    properties['barcode_name'] = barcode_name

                if not os.path.isfile(fastq_name_v2):
                    shutil.move(filename, fastq_name_v2)
                fastq_file = dxpy.upload_local_file(filename = fastq_name_v2, 
                                                    properties = properties, 
                                                    project = self.lane_project_id, 
                                                    folder = fastqs_subfolder, 
                                                    parents = True)
                fastq_files.append(dxpy.dxlink(fastq_file))

        # Upload all the fastq files from the flowcell directory (Unaligned_L%d/<flowcell_id>)
        os.chdir(flowcell_dir)
        for filename in os.listdir('.'):
            if fnmatch.fnmatch(filename, '*.fastq.gz'):
                scgpm_names = self.get_SCGPM_fastq_name_rta_v2(filename)
                scgpm_fastq_name = scgpm_names[0]
                barcode = scgpm_names[1]
                try:
                    barcode_name = self.barcode_dict[barcode]
                except:
                    barcode_name = None
                read_index = scgpm_names[2]
                if barcode_name:
                    fastq_name_v2 = 'SCGPM_%s_%s_L%d_%s_%s_R%d.fastq.gz' % (self.library_name, 
                                                                            self.flowcell_id,
                                                                            self.lane_index,  
                                                                            barcode,
                                                                            barcode_name, 
                                                                            int(read_index))
                else:
                    fastq_name_v2 = 'SCGPM_%s_%s_L%d_%s_R%d.fastq.gz' % (self.library_name, 
                                                                         self.flowcell_id,
                                                                         self.lane_index,  
                                                                         barcode,
                                                                         int(read_index))
                properties = {
                              'barcode': str(barcode),
                              'read': str(read_index),
                              'run_name': str(self.run_name),
                              'lane_index': str(self.lane_index),
                              'run_date': str(self.run_date),
                              'library_id': str(self.library_id),
                              'lane_id': str(self.lane_id),
                              'library_name': str(self.library_name)
                             }
                if barcode_name:
                    properties['barcode_name'] = str(barcode_name)

                if not os.path.isfile(fastq_name_v2):
                    shutil.move(filename, fastq_name_v2)
                fastq_file = dxpy.upload_local_file(filename = fastq_name_v2, 
                                                    properties = properties, 
                                                    project = self.lane_project_id, 
                                                    folder = fastqs_subfolder, 
                                                    parents = True)
                fastq_files.append(dxpy.dxlink(fastq_file))
    else:
        print 'Error: bcl2fastq applet not equipped to handle RTA version %d files' % self.bcl2fastq_version
        sys.exit()
    
    print 'Uploaded fastq files:'
    for dxlink in fastq_files:
        print dxlink

    output = {
              'fastqs': fastq_files,
              'lane_html': dxpy.dxlink(lane_html_file)
             }
    return(output)


def sponsor_project():


def write_tools_used():


class Bcl2fastqJob:
    """Converts illumina intensity files to fastqs.

    Args:
        bcl2fastq_args (dict): bcl2fastq command-line arguments.
        lane_index (int): Index of illumina flowcell lane.
    """

    def __init__(self, lane_index):

        self.lane_index = lane_index

        self.barcodes = {}
        self.command_line_args = None

    def parse_barcodes_file(self, barcodes_file, lane_index):
        """Parse barcode sequences and names from text file.

        This function should also include lane index so that users could 
        process an entire run.

        Args:
            barcodes_file (str): Path to text file with each set of barcodes 
                & names on separate lines.
        """

        with open(barcodes_file, 'r') as BARCODES:
            n = 0
            for line in BARCODES:
                n += 1
                elements = line.split()
                if len(elements) == 2:
                    barcode = elements[0].upper()
                    name = elements[1]
                    self.barcodes[barcode] = name
                elif len(elements) == 1:
                    barcode = elements[0].upper()
                    self.barcodes[barcode] = None
                else:
                    err_msg = 'Error: %s ' % barcodes_file
                    err_msg += 'has %d barcodes on line %d' % (len(elements), n)
                    print err_msg
                    sys.exit()

    def create_sample_sheet(self, barcodes):
        """Creates sample sheet for bcl2fastq.
        """

        i7 = None
        i5 = None
        name = None
        sample_id = None
        sample_sheet_path = 'samplesheet.csv'

        SHEET = open(sample_sheet_path, 'w')
        samplesheet.write('[Data]')
        SHEET.write('Lane,Sample_ID,index,index2')

        with open(self.barcodes_file, 'r') as CODES:
            for line in CODES:
                sample_id_list = []
                elements = line.split()
                barcode = elements[0]
                
                if len(elements) == 2:
                    name = elements[1]
                    sample_id_list.append(name)
                else:
                    name = None

                indexes = barcode.split('-')
                i7 = indexes[0]
                sample_id_list.append(i7)

                if len(indexes) == 2:
                    i5 = indexes[1]
                    sample_id_list.append(i5)
                elif len(indexes) > 2:
                    THROW ERROR
                else:
                    i5 = None

                sample_id = '-'.join(sample_id_list)
                if i5:
                    SHEET.write('%d,%s,%s,%s' % (self.lane_index, sample_id, i7, i5))
                else:
                    SHEET.write('%d,%s,%s' % (self.lane_index, sample_id, i7))
        SHEET.close()

        return(sample_sheet_path)

    def run(self, command_line_args):
        '''Run bcl2fastq program.

        DEV: Change definition line to "def run_bcl2fastq(self, **optional_params)"
        bcl2fastq --output-dir ${new_run_dir}/${seq_run_name}/Unaligned_L${SGE_TASK_ID}
            --sample-sheet ${new_run_dir}/${seq_run_name}/${seq_run_name}_L${SGE_TASK_ID}_samplesheet.csv
            --ignore-missing-bcls
            --ignore-missing-filter
            --ignore-missing-positions
            --barcode-mismatches 1
            --use-bases-mask ${SGE_TASK_ID}:Y*,n*,Y*
        '''

        self.output_dir = 'Unaligned_L%d' % self.lane_index

        ## DEV : set all --ignore flags to on by default (consistent with existing practices)

        # bcl2fastq version 2 for HiSeq 4000s
        if self.bcl2fastq_version == 2:
            self.output_dir = 'Unaligned_L%d' % self.lane_index
            
            command = 'bcl2fastq ' 
            command += '--output-dir %s ' % self.output_dir
            command += '--sample-sheet %s ' % self.sample_sheet
            command += '--barcode-mismatches %d ' % mismatches
            command += '--use-bases-mask %d:%s ' % (int(self.lane_index), self.use_bases_mask)
            if test_mode and tiles:
                command += '--tiles %d ' % tiles
            if with_failed_reads:
                command += '--with-failed-reads '
            if ignore_missing_bcl:
                command += '--ignore-missing-bcls '
            if ignore_missing_positions:
                command += '--ignore-missing-positions '
            if ignore_missing_filter:
                command += '--ignore-missing-filter '

            print 'Running bcl2fastq v2 with command:'
            print command

            tools_used['commands'].append(command)
            stdout,stderr = self.createSubprocess(cmd=command, pipeStdout=True)


class GetUseBasesMaskJob:
    """Calculates use_bases_mask value from barcodes & RunInfo.xml.

    Args:
        barcodes (dict): Key: barcode sequence, Value: barcode name.
        lane_index (int): Index of illumina flowcell lane.
        runinfo (str): Path to RunInfo.xml file.
    """

    def __init__(self, sample_sheet_file, run_info_file, lane_index):

        self.sample_sheet_file = sample_sheet_file
        self.run_info_file = run_info_file
        self.lane_index = int(lane_index)

        self.barcodes = None
        self.read_config = None
        self.barcode_length = None
        self.use_bases_mask = None

    def parse_run_info(self, run_info_file):
        """Parses the RunInfo.xml file. Returns a list of dicts, each
        describing the configuration of one read. """

        reads = []

        tree = ET.parse(run_info_file)

        for read_elt in tree.findall(".//Read"):
            read_desc = {}

            read_desc['Number'] = int(read_elt.get('Number'))
            read_desc['NumCycles'] = int(read_elt.get('NumCycles'))

            is_indexed = read_elt.get('IsIndexedRead')
            if is_indexed == 'Y':
                read_desc['IsIndexedRead'] = True
            elif is_indexed == 'N':
                read_desc['IsIndexedRead'] = False
            else:
                raise RuntimeError('Invalid value for IsIndexedRead: %s' % is_indexed)

            reads.append(read_desc)

        print >> sys.stderr, 'read_config: %s' % read_config
        return sorted(reads, key=lambda read_desc: read_desc['Number'])

    def parse_sample_sheet(self, sample_sheet_file, lane_index):
        """Parses the sample sheet CSV file and returns a list of the
        barcode(s) for the given lane."""

        barcodes = []

        with open(sample_sheet_file, 'r') as sfile:
            for line in sfile:
                line = line.strip()
                if line == '[Data]':
                    continue    # first line
                fields = line.split(',')

                assert len(fields) == 6, "Expected 6 fields but found %s; line '%s'" % (len(fields), line)

                if fields[0] == 'Sample_Project':
                    # header line
                    continue
                elif int(fields[1]) != lane_index:
                    # wrong lane
                    continue
                else:
                    barcode_pattern = '-'.join(fields[4:6])
                    barcodes.append(barcode_pattern)

        return barcodes

    def get_use_bases_mask(self, read_config, barcode_length):
        """Calculates the correct value of --use-bases-mask, given the read
        configuration and barcode length(s) determined from the sample
        sheet."""

        components = []

        for read_desc in read_config:
            if read_desc['IsIndexedRead'] == False:
                # non-index read: keep all bases
                components.append('y%d' % read_desc['NumCycles'])
            else:
                # index read: construct based on barcode length
                read_len = read_desc['NumCycles']
                barcode_len = None
                if read_desc['Number'] == 2:
                    # first index
                    barcode_len = barcode_length[0]
                elif read_desc['Number'] == 3:
                    # second index
                    barcode_len = barcode_length[1]
                else:
                    sys.exit('Invalid read number for index read: %d' % read_desc['Number'])

                icomp = ''
                if barcode_len != 0:
                    icomp = 'I%d' % barcode_len

                ncomp = ''
                if read_len - barcode_len != 0:
                    ncomp = 'n%d' % (read_len - barcode_len)

                components.append(icomp + ncomp)

        print >> sys.stderr, 'use_bases_mask: %s' % self.use_bases_mask
        return ','.join(components)

    def get_true_barcode_length(self, barcodes):
        """Get actual barcode length based on barcode sequence composition.
        (I think)
        """
        barcode_lengths = [self._get_barcode_length(bc) for bc in barcodes]
        print >> sys.stderr, 'barcode_lengths: %s' % barcode_lengths

        distinct_lengths = self._get_distinct_lengths(barcode_lengths)
        print >> sys.stderr, 'distinct_lengths: %s' % distinct_lengths

        barcode_length = self._get_actual_barcode_length(distinct_lengths)
        print >> sys.stderr, 'barcode_length: %s' % (barcode_length,)

        if barcode_length == None:
            print >> sys.stderr, 'Found no barcodes'
            barcode_length = (0, 0)
        elif isinstance(barcode_length, int):
            print >> sys.stderr, 'Found single-index barcodes of length %s' % barcode_length
            barcode_length = (barcode_length, 0)
        elif isinstance(barcode_length, tuple):
            print >> sys.stderr, 'Found dual-index barcodes of lengths %s and %s' % barcode_length

        print >> sys.stderr, 'barcode_length: %s' % (self.barcode_length,)
        return barcode_length

    def run(self):

        self.read_config = self.parse_run_info(self.run_info_file)
        
        self.barcodes = self.parse_sample_sheet(self.sample_sheet_file, self.lane_index)
        
        self.barcode_length = self.get_true_barcode_length(self.barcodes)
        
        self.use_bases_mask = self.get_use_bases_mask(self.read_config, self.barcode_length)
        
        return self.use_bases_mask

    def _get_barcode_length(self, barcode):
        """Returns the length of the given barcode. If the barcode is empty or
        'Undetermined', returns None. If the barcode is a dual-indexed barcode,
        returns a tuple containing the lengths of the two parts. Otherwise,
        returns the length of the barcode."""

        if barcode == '' or barcode == 'Undetermined':
            return None
        elif '-' in barcode:
            barcodes = barcode.split('-')
            assert len(barcodes) == 2
            return (len(barcodes[0]), len(barcodes[1]))
        else:
            return len(barcode)

    def _get_distinct_length(self, barcode_lengths):
        """Given a list of barcode lengths, possibly including None, returns a
        list of the distinct lengths, excluding None."""

        len_set = {bc_len for bc_len in barcode_lengths if bc_len != None}
        return list(len_set)

    def _get_actual_barcode_length(self, barcode_lengths):
        """Verify that the given list of barcode lengths contains a single
        element, and return it."""

        if len(barcode_lengths) == 0:
            return None
        elif len(barcode_lengths) == 1:
            return barcode_lengths[0]
        else:
            sys.exit('Found multiple barcode lengths (%s) in sample sheet; exiting...')


def get_lane_barcode(self):
    run_params_file = 'runParameters.xml'
    if not os.path.isfile(run_params_file):
        print 'Error: Could not find %s' % run_params_file
        sys.exit()
    with open(run_params_file, 'r') as PARAM:
        for line in PARAM:
            match = re.search(r'<Barcode>([\w-]+)</Barcode>', line)
            if match:
                lane_barcode = match.group(1)
                return lane_barcode
    print 'Error: Could not determine lane barcode from %s' % run_params_file
    sys.exit()


def get_flowcell_id(self):
    ''' Description: Get flowcell ID from samplesheet generated from LIMS.
    '''

    if not self.sample_sheet:
        warning = 'Warning: Cannot get flowcell ID without creating '
        warning += 'samplesheet. Creating samplesheet now.'
        self.sample_sheet = self.create_sample_sheet()

    get_flowcell_id_from_line = False
    with open(self.sample_sheet, 'r') as SAMPLE_SHEET:
        for line in SAMPLE_SHEET:
            elements = line.split(',')
            if get_flowcell_id_from_line == True:
                self.flowcell_id = elements[0]
                break
            elif elements[0] == 'FCID' or elements[0] == 'Sample_Project':
                # RTA v1 == 'FCID', RTA v2 == 'Sample_Project'
                get_flowcell_id_from_line = True
            else:
                continue

    if not self.flowcell_id:
        print 'Error: Could not get flowcell ID from sample sheet'
        sys.exit()
    else:
        # Add flowcell ID as a record property
        input_params = {
                        'project': self.record.project, 
                        'properties': {'flowcell_id': self.flowcell_id}
                       }
        print input_params
        dxpy.api.record_set_properties(object_id = self.record.id,
                                       input_params = input_params)
        return self.flowcell_id


def get_use_bases_mask(self, output_folder):
    '''
    command = "python calculate_use_bases_mask.py {runinfoFile} {sampleSheet} {lane}"
    gbsc_utils.createSubprocess(cmd=command)
    '''
    
    misc_subfolder = output_folder + '/miscellany'
    run_info_file = 'RunInfo.xml'

    command = 'python calculate_use_bases_mask.py %s ' % run_info_file
    command += '%s ' % self.sample_sheet
    command += '%d ' % int(self.lane_index)
    command += '%d' % int(self.bcl2fastq_version)

    stdout,stderr = self.createSubprocess(cmd=command, pipeStdout=True)
    self.use_bases_mask = stdout
    print 'This is use_bases_mask value: %s' % self.use_bases_mask

    use_bases_mask_file = 'use_bases_mask.txt'
    with open(use_bases_mask_file, 'w') as OUT:
        OUT.write(self.use_bases_mask)
    dxpy.upload_local_file(filename = use_bases_mask_file, 
                           properties = None, 
                           project = self.lane_project_id, 
                           folder = misc_subfolder, 
                           parents = True)
    return self.use_bases_mask


@dxpy.entry_point("main")
def main(**applet_input):
    ''' Description: Use illumina bcl2fastq applet to perform demultiplex and 
    convert bcl files to fastq files. Currently handles files generated from
    RTA version 2.7.3 and earlier.

    Input:
    applet_input (dictionary): Input parameters specified when calling applet 
                               from DNAnexus
    '''

    ## Define all variables here

    params = InputParameters(applet_input)
    tools_used_dict = {'name': 'Bcl to Fastq Conversion and Demultiplexing', 'commands': []}

    lane = FlowcellLane(record_link=params.record_link)
    lane.describe()
    
    print 'Downloading lane data'
    lane.unpack_tar(params.lane_data_tar)
    lane.unpack_tar(params.metadata_tar)
    
    print 'Creating sample sheet\n'
    lane.create_sample_sheet(params.output_folder)

    print 'Parsing sample sheet to get flowcell ID'
    lane.get_flowcell_id()
    
    print 'Get use bases mask\n'
    lane.get_use_bases_mask(params.output_folder)
    
    print 'Convert bcl to fastq files'
    lane.run_bcl2fastq(mismatches = params.mismatches,
                       ignore_missing_stats = params.ignore_missing_stats,
                       ignore_missing_bcl = params.ignore_missing_bcl,
                       with_failed_reads = params.with_failed_reads,
                       ignore_missing_positions = params.ignore_missing_positions,
                       ignore_missing_filter = params.ignore_missing_filter,
                       tiles = params.tiles,
                       test_mode = params.test_mode,
                       tools_used = tools_used_dict
                       )
    
    print 'Uploading fastq files back to DNAnexus'
    upload_output = lane.upload_result_files(params.output_folder)        # returns DXLink objects
    #print EMPTY_DEBUG_VARIABLE

    # Create tools used file
    tools_used_file = 'bcl2fastq_tools_used.json'
    with open(tools_used_file, 'w') as TOOLS:
        TOOLS.write(json.dumps(tools_used_dict))
    misc_subfolder = params.output_folder + '/miscellany'
    tools_used_id = dxpy.upload_local_file(filename = tools_used_file, 
                           properties = None, 
                           project = lane.lane_project_id, 
                           folder = misc_subfolder, 
                           parents = True
                          )

    output = {}
    output['fastqs'] = upload_output['fastqs']
    output['lane_html'] = upload_output['lane_html']
    output['tools_used'] = dxpy.dxlink(tools_used_id)

    #print DEBUG_STOP

    print 'Output'
    print output
    return output

dxpy.run()
